栈内存:  1. 是一种连续储存的数据结构，具有先进后出的性质。想要读取栈中的某个元素，就要将其之前的所有元素出栈才能完成。类比羽毛球桶。
        2. 栈内存存储程序运行时分配的局部变量
        3. const局部变量也存储在栈内存
        4. 由程序自动申请分配，回收；程序员无法控制
        5. 栈内存向地址减小的方向增长
        
        #include <iostream>
        int main(int argc, const char * argv[]) {
            // insert code here...
            int i = 10; //变量i储存在栈区中
            const int i2 = 20;
            int i3 = 30;
            std::cout << &i << " " << &i2 << " " << &i3 << std::endl;
            return 0;
        }
        //输出结果：0x7ffeefbff5bc 0x7ffeefbff5b8 0x7ffeefbff5b4 内存地址不断减小，且地址是连续的。
        
堆内存: 1. 是一种非连续的树形存储结构，每个节点有一个值，用于存储程序员申请的内存空间。
       2. 程序员向操作系统申请一块内存，当系统收到程序的申请时，会遍历一个记录空闲内存地址的链表，寻找第一个空间大于所申请空间的堆结点，
         然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。分配的速度较慢，地址不连续，容易碎片化。
         此外，由程序员申请，同时也必须由程序员负责销毁，否则则导致内存泄露。
       3. 堆内元素存取随意
       
        #include <iostream>
        int main(int argc, const char * argv[]) {
            int i = 10; //变量i储存在栈区中
            char pc[] = "hello!"; //储存在栈区
            const double cd = 99.2; //储存在栈区
            static long si = 99; //si储存在可读写区，专门用来储存全局变量和静态变量的内存
            int* pi = new int(100); //指针pi指向的内存是在 堆区，专门储存程序运行时分配的内存
            std::cout << &i << " " << &pc << " " << &cd << " " << &si << " " << pi << std::endl;
            delete pi; //需程序员自己释放
            return 0;
        }
        //输出结果：0x7ffeefbff5bc 0x7ffeefbff5b5 0x7ffeefbff5a8 0x1000020d8 0x100602600 运行多次pi地址不是连续的
                  static的si地址是一致的

new运算符用于申请内存空间：
        1. 先申请内存，后构造函数
        2. new申请内存之后，应该立即检查指针值是否为NULL。防止使用指针值为NULL的内存。
        3. 不要忘记为数组和动态内存赋初值。防止将未被初始化的内存作为右值使用。
delete运算符用于释放内存      
        1. 先析构函数，再释放内存空间
        2. delete释放了内存之后，立即将指针设置为NULL，防止产生“野指针”。
